import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdtempSync, mkdirSync, readFileSync, writeFileSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { generateReact } from '../src/generators/react.js';
import { generateVue } from '../src/generators/vue.js';
import { generateSvelte } from '../src/generators/svelte.js';
import { generateAngular } from '../src/generators/angular.js';
import { generateSolid } from '../src/generators/solid.js';
import { generatePreact } from '../src/generators/preact.js';
import { generateHTML } from '../src/generators/html.js';
import { generateCSS } from '../src/generators/css.js';

/** @type {import('../src/parser.js').ComponentMeta} */
const meta = {
  tag: 'arc-button',
  className: 'ArcButton',
  pascalName: 'Button',
  tier: 'reactive',
  props: [
    { name: 'variant', type: 'String', default: "'primary'", reflect: true, values: ['primary', 'secondary'] },
    { name: 'disabled', type: 'Boolean', default: 'false', reflect: true, values: [] },
  ],
  css: ':host { display: inline-flex; } :host([variant="primary"]) { background: blue; } .btn { border: none; }',
  template: '<button class="btn"><slot></slot></button>',
  events: ['arc-click'],
  interactivity: 'static',
  hostDisplay: 'inline-flex',
};

let tmpDir;

beforeEach(() => {
  tmpDir = mkdtempSync(join(tmpdir(), 'prism-test-'));
});

afterEach(() => {
  rmSync(tmpDir, { recursive: true, force: true });
});

const config = (outSub) => ({
  outDir: outSub,
  wcPackage: '@arclux/arc-ui',
  barrels: false,
});

describe('generateReact', () => {
  it('produces a .ts file with createComponent', () => {
    const result = generateReact(meta, config('out/react'), tmpDir);
    expect(result.written).toBe(true);
    const content = readFileSync(result.path, 'utf-8');
    expect(content).toContain('createComponent');
    expect(content).toContain('ArcButton');
    expect(content).toContain("'primary' | 'secondary'");
    expect(content).toContain('onArcClick');
  });
});

describe('generateVue', () => {
  it('produces a .vue SFC', () => {
    const result = generateVue(meta, config('out/vue'), tmpDir);
    expect(result.written).toBe(true);
    const content = readFileSync(result.path, 'utf-8');
    expect(content).toContain('<script setup lang="ts">');
    expect(content).toContain('defineProps');
    expect(content).toContain('arc-button');
  });
});

describe('generateSvelte', () => {
  it('produces a .svelte file', () => {
    const result = generateSvelte(meta, config('out/svelte'), tmpDir);
    expect(result.written).toBe(true);
    const content = readFileSync(result.path, 'utf-8');
    expect(content).toContain('$props()');
    expect(content).toContain('arc-button');
  });
});

describe('generateAngular', () => {
  it('produces a .ts file with @Component', () => {
    const result = generateAngular(meta, config('out/angular'), tmpDir);
    expect(result.written).toBe(true);
    const content = readFileSync(result.path, 'utf-8');
    expect(content).toContain('@Component');
    expect(content).toContain('CUSTOM_ELEMENTS_SCHEMA');
    expect(content).toContain('@Input()');
  });
});

describe('generateSolid', () => {
  it('produces a .tsx file with splitProps', () => {
    const result = generateSolid(meta, config('out/solid'), tmpDir);
    expect(result.written).toBe(true);
    const content = readFileSync(result.path, 'utf-8');
    expect(content).toContain('splitProps');
    expect(content).toContain('ButtonProps');
  });
});

describe('generatePreact', () => {
  it('produces a .tsx file with FunctionComponent', () => {
    const result = generatePreact(meta, config('out/preact'), tmpDir);
    expect(result.written).toBe(true);
    const content = readFileSync(result.path, 'utf-8');
    expect(content).toContain('FunctionComponent');
    expect(content).toContain('arc-button');
  });
});

describe('generateHTML', () => {
  it('produces .html files for static components', () => {
    const htmlConfig = {
      outDir: 'out/html',
      tokensCSS: 'tokens.css',
      inlineVariant: false,
    };
    const result = generateHTML(meta, htmlConfig, tmpDir);
    expect(result.skipped).toBe(false);
    expect(result.results.length).toBeGreaterThan(0);
    expect(result.results[0].written).toBe(true);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).toContain('Auto-generated by @arclux/prism');
  });

  it('skips interactive components', () => {
    const interactiveMeta = { ...meta, interactivity: 'interactive' };
    const result = generateHTML(interactiveMeta, { outDir: 'out/html' }, tmpDir);
    expect(result.skipped).toBe(true);
  });
});

describe('generateCSS', () => {
  it('produces a .css file with light DOM selectors', () => {
    const cssConfig = { outDir: 'out/css', tokensCSS: 'tokens.css' };
    const result = generateCSS(meta, cssConfig, tmpDir);
    expect(result.skipped).toBe(false);
    expect(result.results[0].written).toBe(true);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).toContain('.arc-button');
    expect(content).not.toContain(':host');
  });
});

describe('manual-file safety', () => {
  it('React — does not overwrite manual file', () => {
    const outDir = join(tmpDir, 'out/react/reactive');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'Button.ts'), '// My manual file\n');

    const result = generateReact(meta, config('out/react'), tmpDir);
    expect(result.written).toBe(false);
  });

  it('Vue — does not overwrite manual file', () => {
    const outDir = join(tmpDir, 'out/vue/reactive');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'Button.vue'), '<template>Manual</template>\n');

    const result = generateVue(meta, config('out/vue'), tmpDir);
    expect(result.written).toBe(false);
  });

  it('Svelte — does not overwrite manual file', () => {
    const outDir = join(tmpDir, 'out/svelte/reactive');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'Button.svelte'), '<div>Manual</div>\n');

    const result = generateSvelte(meta, config('out/svelte'), tmpDir);
    expect(result.written).toBe(false);
  });

  it('Angular — does not overwrite manual file', () => {
    const outDir = join(tmpDir, 'out/angular/reactive');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'Button.ts'), '// Manual Angular\n');

    const result = generateAngular(meta, config('out/angular'), tmpDir);
    expect(result.written).toBe(false);
  });

  it('Solid — does not overwrite manual file', () => {
    const outDir = join(tmpDir, 'out/solid/reactive');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'Button.tsx'), '// Manual Solid\n');

    const result = generateSolid(meta, config('out/solid'), tmpDir);
    expect(result.written).toBe(false);
  });

  it('Preact — does not overwrite manual file', () => {
    const outDir = join(tmpDir, 'out/preact/reactive');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'Button.tsx'), '// Manual Preact\n');

    const result = generatePreact(meta, config('out/preact'), tmpDir);
    expect(result.written).toBe(false);
  });

  it('CSS — does not overwrite manual file', () => {
    const outDir = join(tmpDir, 'out/css');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'button.css'), '/* My manual CSS */\n');

    const cssConfig = { outDir: 'out/css', tokensCSS: 'tokens.css' };
    const result = generateCSS(meta, cssConfig, tmpDir);
    expect(result.results[0].written).toBe(false);
  });
});
