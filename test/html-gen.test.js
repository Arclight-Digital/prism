import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdtempSync, mkdirSync, readFileSync, writeFileSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { generateHTML } from '../src/generators/html.js';

let tmpDir;

beforeEach(() => {
  tmpDir = mkdtempSync(join(tmpdir(), 'prism-html-'));
});

afterEach(() => {
  rmSync(tmpDir, { recursive: true, force: true });
});

const baseMeta = {
  tag: 'arc-badge',
  className: 'ArcBadge',
  pascalName: 'Badge',
  tier: 'content',
  props: [
    { name: 'variant', type: 'String', default: "'info'", reflect: true, values: ['info', 'success', 'warning'] },
  ],
  css: `:host { display: inline-flex; }
:host([variant="info"]) { background: blue; }
:host([variant="success"]) { background: green; }
:host(:hover) { opacity: 0.8; }
.label { font-weight: bold; }`,
  template: '<span class="label"><slot></slot></span>',
  events: [],
  interactivity: 'static',
  hostDisplay: 'inline-flex',
};

const htmlConfig = {
  outDir: 'out/html',
  baseCSS: 'tokens.css',
  prefix: 'arc',
  inlineVariant: false,
};

describe('generateHTML — external variant', () => {
  it('generates a .html file with class-based wrapper', () => {
    const result = generateHTML(baseMeta, htmlConfig, tmpDir);
    expect(result.skipped).toBe(false);
    expect(result.results).toHaveLength(1);
    expect(result.results[0].written).toBe(true);

    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).toContain('Auto-generated by @arclux/prism');
    expect(content).toContain('class="arc-badge"');
    expect(content).toContain('badge.css');
  });

  it('uses <span> wrapper for inline display', () => {
    const result = generateHTML(baseMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).toContain('<span');
  });

  it('uses <div> wrapper for block display', () => {
    const blockMeta = { ...baseMeta, hostDisplay: 'block' };
    const result = generateHTML(blockMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).toContain('<div');
  });

  it('strips Lit ${...} expressions from template', () => {
    const exprMeta = {
      ...baseMeta,
      template: '<span class="label">${this.heading}</span>',
    };
    const result = generateHTML(exprMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).not.toContain('${');
    expect(content).toContain('Heading');
  });

  it('replaces <slot> with label text', () => {
    const result = generateHTML(baseMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).not.toContain('<slot');
    expect(content).toContain('Badge');
  });

  it('strips Lit binding attributes', () => {
    const bindingMeta = {
      ...baseMeta,
      template: '<button @click="${this._handleClick}" .value="${this.val}" ?disabled="${this.disabled}"><slot></slot></button>',
    };
    const result = generateHTML(bindingMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).not.toContain('@click');
    expect(content).not.toContain('.value');
    expect(content).not.toContain('?disabled');
  });

  it('strips part attributes', () => {
    const partMeta = {
      ...baseMeta,
      template: '<span part="label"><slot></slot></span>',
    };
    const result = generateHTML(partMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).not.toContain('part=');
  });
});

describe('generateHTML — inline variant', () => {
  const inlineConfig = { ...htmlConfig, inlineVariant: true };

  it('generates both external and inline files', () => {
    const result = generateHTML(baseMeta, inlineConfig, tmpDir);
    expect(result.results).toHaveLength(2);
    expect(result.results[0].path).toContain('badge.html');
    expect(result.results[1].path).toContain('badge.inline.html');
  });

  it('inline variant includes style attributes', () => {
    const result = generateHTML(baseMeta, inlineConfig, tmpDir);
    const content = readFileSync(result.results[1].path, 'utf-8');
    expect(content).toContain('self-contained');
    // Should have converted :host to class-based CSS
    expect(content).not.toContain(':host');
  });

  it('inline variant includes <style> block for pseudo-states', () => {
    const result = generateHTML(baseMeta, inlineConfig, tmpDir);
    const content = readFileSync(result.results[1].path, 'utf-8');
    // :host(:hover) should produce a <style> block since hover can't be inline
    expect(content).toContain('<style>');
    expect(content).toContain(':hover');
  });
});

describe('generateHTML — interactivity filtering', () => {
  it('skips interactive components', () => {
    const interactiveMeta = { ...baseMeta, interactivity: 'interactive' };
    const result = generateHTML(interactiveMeta, htmlConfig, tmpDir);
    expect(result.skipped).toBe(true);
    expect(result.results).toHaveLength(0);
  });

  it('generates for hybrid components', () => {
    const hybridMeta = { ...baseMeta, interactivity: 'hybrid' };
    const result = generateHTML(hybridMeta, htmlConfig, tmpDir);
    expect(result.skipped).toBe(false);
    expect(result.results.length).toBeGreaterThan(0);
  });
});

describe('generateHTML — safety', () => {
  it('does not overwrite manual file (external)', () => {
    const outDir = join(tmpDir, 'out/html');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'badge.html'), '<div>My manual HTML</div>\n');

    const result = generateHTML(baseMeta, htmlConfig, tmpDir);
    expect(result.results[0].written).toBe(false);

    const content = readFileSync(join(outDir, 'badge.html'), 'utf-8');
    expect(content).toContain('My manual HTML');
  });

  it('does not overwrite manual file (inline)', () => {
    const outDir = join(tmpDir, 'out/html');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(join(outDir, 'badge.inline.html'), '<div>Manual inline</div>\n');

    const inlineConfig = { ...htmlConfig, inlineVariant: true };
    const result = generateHTML(baseMeta, inlineConfig, tmpDir);
    // External should write, inline should skip
    expect(result.results[0].written).toBe(true);
    expect(result.results[1].written).toBe(false);
  });

  it('overwrites file that has the generated header', () => {
    const outDir = join(tmpDir, 'out/html');
    mkdirSync(outDir, { recursive: true });
    writeFileSync(
      join(outDir, 'badge.html'),
      '<!-- Auto-generated by @arclux/prism — do not edit manually -->\n<div>Old generated</div>\n',
    );

    const result = generateHTML(baseMeta, htmlConfig, tmpDir);
    expect(result.results[0].written).toBe(true);
  });
});

describe('generateHTML — complex templates', () => {
  it('handles nested elements', () => {
    const nestedMeta = {
      ...baseMeta,
      template: '<div class="outer"><div class="inner"><span class="text"><slot></slot></span></div></div>',
    };
    const result = generateHTML(nestedMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).toContain('class="outer"');
    expect(content).toContain('class="inner"');
  });

  it('handles empty template', () => {
    const emptyMeta = { ...baseMeta, template: '' };
    const result = generateHTML(emptyMeta, htmlConfig, tmpDir);
    expect(result.results[0].written).toBe(true);
  });

  it('handles aria attributes in expressions', () => {
    const ariaMeta = {
      ...baseMeta,
      template: '<button aria-label="${this.label}"><slot></slot></button>',
    };
    const result = generateHTML(ariaMeta, htmlConfig, tmpDir);
    const content = readFileSync(result.results[0].path, 'utf-8');
    expect(content).not.toContain('${');
    expect(content).toContain('aria-label');
  });
});
