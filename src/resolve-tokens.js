// Auto-generated by @arclux/prism — do not edit manually

/**
 * Loads design tokens and resolves CSS custom property references.
 */

import { readFileSync } from 'node:fs';

/**
 * Build a flat map of --token-name → value from tokens.css.
 * @param {string} cssPath - absolute path to tokens.css
 * @returns {Map<string, string>}
 */
export function loadTokenMap(cssPath) {
  const css = readFileSync(cssPath, 'utf-8');
  const map = new Map();

  // Match --prop-name: value; (including multi-line values)
  const propPattern = /(--[\w-]+)\s*:\s*((?:[^;]|(?=\n\s+\S))+);/g;
  let match;
  while ((match = propPattern.exec(css)) !== null) {
    const name = match[1];
    const value = match[2].trim().replace(/\s+/g, ' ');
    map.set(name, value);
  }

  return map;
}

/**
 * Resolve all var(--token) references in a CSS string using the token map.
 * Handles nested var() and fallback values.
 * @param {string} css
 * @param {Map<string, string>} tokenMap
 * @returns {string}
 */
export function resolveTokens(css, tokenMap) {
  // Iteratively resolve var() references (handles nesting)
  let resolved = css;
  let maxIterations = 10;

  const seen = new Set();
  while (maxIterations-- > 0 && resolved.includes('var(--')) {
    const before = resolved;
    resolved = resolved.replace(
      /var\((--[\w-]+)(?:\s*,\s*([^)]*))?\)/g,
      (full, name, fallback) => {
        if (seen.has(name)) {
          // Circular reference — stop resolving this token
          return fallback !== undefined ? fallback.trim() : full;
        }
        if (tokenMap.has(name)) {
          seen.add(name);
          return tokenMap.get(name);
        }
        if (fallback !== undefined) {
          return fallback.trim();
        }
        return full; // Leave unresolved
      }
    );
    if (resolved === before) break; // No more replacements
  }

  return resolved;
}
