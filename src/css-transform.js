// Auto-generated by @arclux/prism — do not edit manually

/**
 * Shared shadow DOM → light DOM CSS transformation logic.
 * Used by both css-gen.js and html-gen.js.
 */

/**
 * Convert shadow DOM CSS to light DOM CSS.
 *
 * Handles :host() selectors with attributes, pseudo-classes, pseudo-elements,
 * :not() negations, and scopes unqualified inner selectors under the component class.
 *
 * @param {string} css - raw shadow DOM CSS
 * @param {string} tag - component tag name (e.g. 'arc-button')
 * @returns {string}
 */
export function shadowToLight(css, tag) {
  let result = css;

  // --- :host(:not(...)) variants (must come before general :host(...) rules) ---

  // :host(:not([prop="value"])) → .tag:not([data-prop="value"])
  result = result.replace(
    /:host\(:not\(\[([\w-]+)="([^"]+)"\]\)\)/g,
    `.${tag}:not([data-$1="$2"])`
  );

  // :host(:not([prop])) → .tag:not([data-prop])
  result = result.replace(
    /:host\(:not\(\[([\w-]+)\]\)\)/g,
    `.${tag}:not([data-$1])`
  );

  // --- :host([attr]...) with combined pseudo-class/pseudo-element ---

  // :host([attr="value"]::pseudo-element) → .tag[data-attr="value"]::pseudo-element
  result = result.replace(
    /:host\(\[([\w-]+)="([^"]+)"\](::?[a-z][\w-]*)\)/g,
    `.${tag}[data-$1="$2"]$3`
  );

  // :host([attr]::pseudo-element) → .tag[attr]::pseudo-element
  result = result.replace(
    /:host\(\[([\w-]+)\](::?[a-z][\w-]*)\)/g,
    `.${tag}[$1]$2`
  );

  // --- :host([attr]) basic variants ---

  // :host([prop="value"]) → .tag[data-prop="value"]
  result = result.replace(
    /:host\(\[([\w-]+)="([^"]+)"\]\)/g,
    `.${tag}[data-$1="$2"]`
  );

  // :host([attr]) (boolean) → .tag[attr]
  result = result.replace(
    /:host\(\[([\w-]+)\]\)/g,
    `.${tag}[$1]`
  );

  // --- :host(pseudo) ---

  // :host(::pseudo-element) → .tag::pseudo-element
  // :host(:pseudo-class) → .tag:pseudo-class
  result = result.replace(
    /:host\((::?[a-z][\w-]*)\)/g,
    `.${tag}$1`
  );

  // --- bare :host ---

  // :host { → .tag {
  result = result.replace(/:host\b/g, `.${tag}`);

  // --- Scope inner selectors ---
  // Lines like `.btn {` → `.tag .btn {`
  // Also handles combinators: `.parent > .child` → `.tag .parent > .child`
  // Only scopes the first selector part on each line; combinators are preserved.

  const escapedTag = tag.replace(/-/g, '\\-');
  const scopePattern = new RegExp(
    `^(\\s*)(\\.(?!${escapedTag})[\\w-]+)(\\s*[>+~])?`,
    'gm'
  );
  result = result.replace(scopePattern, (match, indent, selector, combinator) => {
    if (combinator) {
      // e.g. `.parent > ` → `.tag .parent > `
      return `${indent}.${tag} ${selector}${combinator}`;
    }
    return `${indent}.${tag} ${selector}`;
  });

  return result;
}
