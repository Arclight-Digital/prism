// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates Solid component (.tsx) files from ComponentMeta.
 * Uses splitProps() for reactivity-safe prop forwarding.
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const HEADER = '// Auto-generated by @arclux/prism — do not edit manually';

/**
 * Map a WC property type to a TypeScript type string.
 */
function tsType(prop) {
  if (prop.values && prop.values.length > 0) {
    return prop.values.map((v) => `'${v}'`).join(' | ');
  }
  switch (prop.type) {
    case 'Boolean': return 'boolean';
    case 'Number':  return 'number';
    case 'Array':   return 'unknown[]';
    case 'Object':  return 'Record<string, unknown>';
    default:        return 'string';
  }
}

/**
 * Generate a Solid component .tsx file.
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - solid config section
 * @param {string} root - project root
 * @returns {{ path: string, written: boolean }}
 */
export function generateSolid(meta, config, root) {
  const outDir = join(root, config.outDir, meta.tier);
  const outPath = join(outDir, `${meta.pascalName}.tsx`);

  // Safety: never overwrite files without our header
  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const wcImport = config.wcPackage || '@arclux/arc-ui';
  const lines = [HEADER, ''];

  lines.push(`import { splitProps, type Component, type JSX } from 'solid-js';`);
  lines.push(`import '${wcImport}';`);
  lines.push('');

  // Props interface
  lines.push(`export interface ${meta.pascalName}Props {`);
  for (const prop of meta.props) {
    lines.push(`  ${prop.name}?: ${tsType(prop)};`);
  }
  lines.push('  children?: JSX.Element;');
  lines.push('  [key: string]: unknown;');
  lines.push('}');
  lines.push('');

  // Component
  const propNames = meta.props.map((p) => `'${p.name}'`);
  propNames.push(`'children'`);

  const attrs = meta.props.map((p) => `${p.name}={local.${p.name}}`).join(' ');
  const attrStr = attrs ? ` ${attrs} {...rest}` : ' {...rest}';

  lines.push(`export const ${meta.pascalName}: Component<${meta.pascalName}Props> = (props) => {`);
  lines.push(`  const [local, rest] = splitProps(props, [${propNames.join(', ')}]);`);
  lines.push(`  return (`);
  lines.push(`    <${meta.tag}${attrStr}>`);
  lines.push(`      {local.children}`);
  lines.push(`    </${meta.tag}>`);
  lines.push(`  );`);
  lines.push(`};`);
  lines.push('');

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}
