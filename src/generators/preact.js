// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates Preact component (.tsx) files from ComponentMeta.
 * Native CE support — no wrapper library needed.
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const HEADER = '// Auto-generated by @arclux/prism — do not edit manually';

/**
 * Map a WC property type to a TypeScript type string.
 */
function tsType(prop) {
  if (prop.values && prop.values.length > 0) {
    return prop.values.map((v) => `'${v}'`).join(' | ');
  }
  switch (prop.type) {
    case 'Boolean': return 'boolean';
    case 'Number':  return 'number';
    case 'Array':   return 'unknown[]';
    case 'Object':  return 'Record<string, unknown>';
    default:        return 'string';
  }
}

/**
 * Generate a Preact component .tsx file.
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - preact config section
 * @param {string} root - project root
 * @returns {{ path: string, written: boolean }}
 */
export function generatePreact(meta, config, root) {
  const outDir = join(root, config.outDir, meta.tier);
  const outPath = join(outDir, `${meta.pascalName}.tsx`);

  // Safety: never overwrite files without our header
  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const wcImport = config.wcPackage;
  const lines = [HEADER, ''];

  lines.push(`import { type FunctionComponent } from 'preact';`);
  lines.push(`import '${wcImport}';`);
  lines.push('');

  // Props interface
  lines.push(`export interface ${meta.pascalName}Props {`);
  for (const prop of meta.props) {
    lines.push(`  ${prop.name}?: ${tsType(prop)};`);
  }
  lines.push('  children?: preact.ComponentChildren;');
  lines.push('  [key: string]: unknown;');
  lines.push('}');
  lines.push('');

  // Component
  const destructured = meta.props.map((p) => p.name);
  destructured.push('children');
  const destructStr = destructured.join(', ');

  const attrs = meta.props.map((p) => `${p.name}={${p.name}}`).join(' ');
  const attrStr = attrs ? ` ${attrs} {...rest}` : ' {...rest}';

  lines.push(`export const ${meta.pascalName}: FunctionComponent<${meta.pascalName}Props> = ({ ${destructStr}, ...rest }) => (`);
  lines.push(`  <${meta.tag}${attrStr}>`);
  lines.push(`    {children}`);
  lines.push(`  </${meta.tag}>`);
  lines.push(`);`);
  lines.push('');

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}
