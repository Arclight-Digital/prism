// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates Vue 3 SFC (.vue) files from ComponentMeta.
 * Uses defineProps with TS generics and defineEmits for type safety.
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const HEADER = '<!-- Auto-generated by @arclux/prism — do not edit manually -->';

/**
 * Map a WC property type to a TypeScript type string.
 */
function tsType(prop) {
  if (prop.values && prop.values.length > 0) {
    return prop.values.map((v) => `'${v}'`).join(' | ');
  }
  switch (prop.type) {
    case 'Boolean': return 'boolean';
    case 'Number':  return 'number';
    case 'Array':   return 'unknown[]';
    case 'Object':  return 'Record<string, unknown>';
    default:        return 'string';
  }
}

/**
 * Format a default value for Vue's withDefaults().
 */
function vueDefault(prop) {
  if (!prop.default) return undefined;
  const val = prop.default;
  // Strip quotes for string literals — withDefaults uses JS values
  if (val.startsWith("'") || val.startsWith('"')) return val;
  if (val === 'true' || val === 'false') return val;
  if (!isNaN(Number(val))) return val;
  // Arrays/objects need factory functions
  if (val.startsWith('[') || val.startsWith('{')) return `() => (${val})`;
  return `'${val}'`;
}

/**
 * Generate a Vue 3 SFC .vue file for a component.
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - vue config section
 * @param {string} root - project root
 * @returns {{ path: string, written: boolean }}
 */
export function generateVue(meta, config, root) {
  const outDir = join(root, config.outDir, meta.tier);
  const outPath = join(outDir, `${meta.pascalName}.vue`);

  // Safety: never overwrite files without our header
  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const wcImport = config.wcPackage;
  const lines = [HEADER];

  // <script setup lang="ts">
  lines.push('<script setup lang="ts">');
  lines.push(`import '${wcImport}';`);
  lines.push('');
  lines.push(`defineOptions({ name: '${meta.pascalName}' });`);
  lines.push('');

  // Props
  const hasProps = meta.props.length > 0;
  const hasDefaults = meta.props.some((p) => p.default);

  if (hasProps) {
    const propsBlock = meta.props
      .map((p) => `  ${p.name}?: ${tsType(p)};`)
      .join('\n');

    if (hasDefaults) {
      lines.push(`withDefaults(defineProps<{`);
      lines.push(propsBlock);
      lines.push(`}>(), {`);
      for (const prop of meta.props) {
        const def = vueDefault(prop);
        if (def !== undefined) {
          lines.push(`  ${prop.name}: ${def},`);
        }
      }
      lines.push(`});`);
    } else {
      lines.push(`defineProps<{`);
      lines.push(propsBlock);
      lines.push(`}>();`);
    }
  }

  // Events
  if (meta.events.length > 0) {
    lines.push('');
    lines.push(`defineEmits<{`);
    for (const event of meta.events) {
      lines.push(`  '${event}': [event: CustomEvent];`);
    }
    lines.push(`}>();`);
  }

  lines.push('</script>');
  lines.push('');

  // <template>
  lines.push('<template>');

  // Build attribute bindings
  const bindings = meta.props.map((p) => {
    if (p.type === 'Boolean') return `    :${p.name}="${p.name}"`;
    return `    :${p.name}="${p.name}"`;
  });

  if (bindings.length > 0) {
    lines.push(`  <${meta.tag}`);
    lines.push(bindings.join('\n'));
    lines.push(`  >`);
  } else {
    lines.push(`  <${meta.tag}>`);
  }

  lines.push(`    <slot />`);
  lines.push(`  </${meta.tag}>`);
  lines.push('</template>');
  lines.push('');

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}
