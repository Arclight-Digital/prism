// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates Angular standalone component (.ts) files from ComponentMeta.
 * Uses standalone components with CUSTOM_ELEMENTS_SCHEMA (Angular 17+ pattern).
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const HEADER = '// Auto-generated by @arclux/prism — do not edit manually';

/**
 * Map a WC property type to a TypeScript type string.
 */
function tsType(prop) {
  if (prop.values && prop.values.length > 0) {
    return prop.values.map((v) => `'${v}'`).join(' | ');
  }
  switch (prop.type) {
    case 'Boolean': return 'boolean';
    case 'Number':  return 'number';
    case 'Array':   return 'unknown[]';
    case 'Object':  return 'Record<string, unknown>';
    default:        return 'string';
  }
}

/**
 * Format a default value for Angular @Input().
 */
function angularDefault(prop) {
  if (!prop.default) return undefined;
  const val = prop.default;
  if (val.startsWith("'") || val.startsWith('"')) return val;
  if (val === 'true' || val === 'false') return val;
  if (!isNaN(Number(val))) return val;
  if (val.startsWith('[') || val.startsWith('{')) return val;
  return `'${val}'`;
}

/**
 * Convert a custom event name to a camelCase handler name.
 * 'arc-change' → 'arcChange'
 */
function eventToCamel(eventName) {
  return eventName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
}

/**
 * Generate an Angular standalone component .ts file.
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - angular config section
 * @param {string} root - project root
 * @returns {{ path: string, written: boolean }}
 */
export function generateAngular(meta, config, root) {
  const outDir = join(root, config.outDir, meta.tier);
  const outPath = join(outDir, `${meta.pascalName}.ts`);

  // Safety: never overwrite files without our header
  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const wcImport = config.wcPackage || '@arclux/arc-ui';
  const lines = [HEADER, ''];

  // Imports
  const angularImports = ['Component', 'CUSTOM_ELEMENTS_SCHEMA'];
  if (meta.props.length > 0) angularImports.push('Input');
  if (meta.events.length > 0) angularImports.push('Output', 'EventEmitter');

  lines.push(`import { ${angularImports.join(', ')} } from '@angular/core';`);
  lines.push(`import '${wcImport}';`);
  lines.push('');

  // Build template
  const templateAttrs = meta.props.map((p) => {
    if (p.type === 'Boolean') return `[${p.name}]="${p.name}"`;
    return `[attr.${p.name}]="${p.name}"`;
  });

  // Add event listeners in template
  for (const event of meta.events) {
    const camel = eventToCamel(event);
    templateAttrs.push(`(${event})="${camel}.emit($event)"`);
  }

  let template;
  if (templateAttrs.length > 0) {
    template = `<${meta.tag} ${templateAttrs.join(' ')}><ng-content /></${meta.tag}>`;
  } else {
    template = `<${meta.tag}><ng-content /></${meta.tag}>`;
  }

  // @Component decorator
  lines.push(`@Component({`);
  lines.push(`  selector: '${meta.tag}',`);
  lines.push(`  standalone: true,`);
  lines.push(`  schemas: [CUSTOM_ELEMENTS_SCHEMA],`);
  lines.push(`  template: \`${template}\`,`);
  lines.push(`})`);
  lines.push(`export class ${meta.pascalName} {`);

  // @Input() properties
  for (const prop of meta.props) {
    const def = angularDefault(prop);
    if (def !== undefined) {
      lines.push(`  @Input() ${prop.name}: ${tsType(prop)} = ${def};`);
    } else {
      lines.push(`  @Input() ${prop.name}?: ${tsType(prop)};`);
    }
  }

  // @Output() events
  for (const event of meta.events) {
    const camel = eventToCamel(event);
    lines.push(`  @Output() ${camel} = new EventEmitter<CustomEvent>();`);
  }

  lines.push('}');
  lines.push('');

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}
