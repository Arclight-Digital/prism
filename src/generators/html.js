// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates HTML snippet files from ComponentMeta.
 * Two variants:
 *   - component.html — clean template HTML with CSS classes (requires external CSS)
 *   - component.inline.html — same template with inline styles + <style> block for pseudo-states
 *
 * Templates are derived from the Lit render() method, stripped of bindings and slots.
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import { loadTokenMap, resolveTokens } from '../resolve-tokens.js';
import { shadowToLight } from '../css-transform.js';

const HEADER = '<!-- Auto-generated by @arclux/prism — do not edit manually -->';

/**
 * Parse CSS text into an array of rule objects.
 * Handles nested @-rules (media queries, keyframes) by extracting inner rules.
 * @param {string} css
 * @returns {Array<{ selector: string, declarations: string }>}
 */
function parseCSSRules(css) {
  const rules = [];
  const cleaned = css.replace(/\/\*[\s\S]*?\*\//g, '');

  // First extract @media rules
  const mediaPattern = /(@media[^{]+)\{([\s\S]*?\})\s*\}/g;
  let mediaMatch;
  const mediaRanges = [];
  while ((mediaMatch = mediaPattern.exec(cleaned)) !== null) {
    mediaRanges.push({ start: mediaMatch.index, end: mediaMatch.index + mediaMatch[0].length });
    const mediaSelector = mediaMatch[1].trim();
    const innerCSS = mediaMatch[2];
    const innerPattern = /([^{}]+)\{([^{}]*)\}/g;
    let innerMatch;
    while ((innerMatch = innerPattern.exec(innerCSS)) !== null) {
      const selector = innerMatch[1].trim();
      const declarations = innerMatch[2].trim();
      if (selector && declarations) {
        rules.push({ selector, declarations, media: mediaSelector });
      }
    }
  }

  // Then extract top-level rules (not inside @media)
  const rulePattern = /([^{}@]+)\{([^{}]*)\}/g;
  let match;
  while ((match = rulePattern.exec(cleaned)) !== null) {
    // Skip if inside a @media range
    const inMedia = mediaRanges.some(r => match.index >= r.start && match.index < r.end);
    if (inMedia) continue;

    const selector = match[1].trim();
    const declarations = match[2].trim();
    if (selector && declarations && !selector.startsWith('@')) {
      rules.push({ selector, declarations });
    }
  }
  return rules;
}

/**
 * Check if a selector contains pseudo-class states that can't be represented inline.
 */
function hasPseudoState(selector) {
  return /:(?:hover|focus|focus-visible|focus-within|active|visited)\b/.test(selector);
}

/**
 * Collect declarations from a rule string into a Map, skipping transitions.
 */
function parseDeclarations(declarationStr) {
  const props = new Map();
  const decls = declarationStr.split(';').map((d) => d.trim()).filter(Boolean);
  for (const decl of decls) {
    const colonIdx = decl.indexOf(':');
    if (colonIdx === -1) continue;
    const prop = decl.slice(0, colonIdx).trim();
    const value = decl.slice(colonIdx + 1).trim();
    if (prop === 'transition') continue;
    props.set(prop, value);
  }
  return props;
}


/* ── Template conversion ─────────────────────────────────────── */

/**
 * Generate placeholder text for a Lit expression like ${this.heading}.
 */
function placeholderForExpr(expr) {
  // Extract property name: this.heading → heading, this.icon → icon
  const propMatch = expr.match(/this\.(\w+)/);
  if (!propMatch) return '';

  const prop = propMatch[1];
  // Map common property names to sensible placeholder text
  const placeholders = {
    heading: 'Heading',
    title: 'Title',
    description: 'Description text goes here',
    icon: '★',
    label: 'Label',
    text: 'Text content',
    name: 'Name',
    href: '#',
    src: '#',
    value: 'Value',
    content: 'Content goes here',
    subtitle: 'Subtitle text',
    count: '0',
    badge: 'Badge',
  };

  if (placeholders[prop]) return placeholders[prop];

  // Convert camelCase → Title Case
  return prop.replace(/([A-Z])/g, ' $1').replace(/^./, (s) => s.toUpperCase()).trim();
}

/**
 * Strip ${...} expressions from a Lit template, handling nested braces.
 * Replaces with placeholder text based on context.
 * For Lit binding attributes (@event, .prop, ?bool), removes the entire attribute.
 */
function stripExpressions(template) {
  let result = '';
  let i = 0;

  while (i < template.length) {
    // Look for ${
    if (template[i] === '$' && template[i + 1] === '{') {
      // Extract the expression by tracking brace depth
      let depth = 1;
      let j = i + 2;
      while (j < template.length && depth > 0) {
        if (template[j] === '{') depth++;
        else if (template[j] === '}') depth--;
        j++;
      }
      const expr = template.slice(i + 2, j - 1).trim();

      // Check context: are we inside a tag?
      const beforeExpr = result;
      const lastTagOpen = beforeExpr.lastIndexOf('<');
      const lastTagClose = beforeExpr.lastIndexOf('>');
      const inTag = lastTagOpen > lastTagClose;

      if (inTag) {
        // Check if this is a Lit binding attribute: @event=${...}, .prop=${...}, ?attr=${...}
        const litBindingMatch = beforeExpr.match(/\s+([.?@][\w-]+)=$/);

        // Check if this is an unquoted attribute value: name=${...}
        // Determine if we're inside quotes by counting quote chars since last tag open
        const tagContent = beforeExpr.slice(lastTagOpen);
        const doubleQuotes = (tagContent.match(/"/g) || []).length;
        const insideQuotes = doubleQuotes % 2 === 1;
        const unquotedAttrMatch = !insideQuotes && beforeExpr.match(/\s+([\w-]+)=$/);

        if (litBindingMatch) {
          // Remove the Lit binding attribute name + = from result
          result = result.slice(0, result.length - litBindingMatch[0].trimStart().length);
        } else if (unquotedAttrMatch) {
          // Unquoted attribute value — provide quoted placeholder
          const attrName = unquotedAttrMatch[1];
          if (attrName === 'href') result += '"#"';
          else if (attrName === 'role') result += '"presentation"';
          else if (attrName === 'aria-expanded') result += '"false"';
          else if (attrName === 'aria-hidden') result += '"true"';
          else result += `"${placeholderForExpr(expr)}"`;
        } else {
          // Inside a quoted attribute value
          const attrMatch = beforeExpr.match(/([\w-]+)=["'][^"']*$/);
          if (attrMatch) {
            const attrName = attrMatch[1];
            if (attrName === 'href') result += '#';
            else if (attrName === 'src') result += '#';
            else if (attrName === 'class') result += placeholderForExpr(expr);
            else if (attrName === 'aria-label') result += placeholderForExpr(expr);
            else if (attrName === 'aria-expanded') result += 'false';
            else if (attrName === 'role') result += 'presentation';
            else result += placeholderForExpr(expr);
          } else {
            result += placeholderForExpr(expr);
          }
        }
      } else {
        // Text content position
        result += placeholderForExpr(expr);
      }

      i = j;
    } else {
      result += template[i];
      i++;
    }
  }

  return result;
}

/**
 * Remove Lit-specific attribute bindings from the template:
 *  - @event=${...}  (event bindings — already stripped by stripExpressions, but @ prefix remains)
 *  - .prop=${...}   (property bindings)
 *  - ?attr=${...}   (boolean attribute bindings)
 *  - part="..."     (shadow DOM parts)
 */
function stripLitBindings(html) {
  let result = html;

  // Remove @event="..." or @event=value attributes
  result = result.replace(/\s+@[\w-]+="[^"]*"/g, '');
  result = result.replace(/\s+@[\w-]+=\S+/g, '');
  // Remove .prop="..." or .prop=value attributes
  result = result.replace(/\s+\.[\w-]+="[^"]*"/g, '');
  result = result.replace(/\s+\.[\w-]+=\S+/g, '');
  // Remove ?attr="..." or ?attr=value attributes
  result = result.replace(/\s+\?[\w-]+="[^"]*"/g, '');
  result = result.replace(/\s+\?[\w-]+=\S+/g, '');
  // Remove part="..." attributes
  result = result.replace(/\s+part="[^"]*"/g, '');

  return result;
}

/**
 * Replace <slot> elements with placeholder content.
 * - <slot></slot> or <slot>...</slot> → component label text
 * - <slot name="x"></slot> → keep default content or use placeholder
 */
function replaceSlots(html, label) {
  // Named slots with content: <slot name="x">default</slot> → keep default
  let result = html.replace(
    /<slot\s+name="[^"]*">([^<]+)<\/slot>/g,
    (_, content) => content.trim() || label
  );
  // Named slots without content: <slot name="x"></slot> → remove (empty)
  result = result.replace(/<slot\s+name="[^"]*"\s*><\/slot>/g, '');
  // Self-closing named slots
  result = result.replace(/<slot\s+name="[^"]*"\s*\/>/g, '');
  // Default slot with content: <slot>text</slot>
  result = result.replace(/<slot>([^<]+)<\/slot>/g, (_, content) => content.trim() || label);
  // Empty default slot: <slot></slot>
  result = result.replace(/<slot\s*><\/slot>/g, label);
  // Self-closing: <slot/>
  result = result.replace(/<slot\s*\/>/g, label);

  return result;
}

/**
 * Clean up the HTML output: normalize whitespace, remove empty attributes.
 */
function cleanHTML(html) {
  let result = html;

  // Remove empty aria-label=""
  result = result.replace(/\s+aria-label=""/g, '');
  // Remove empty class=""
  result = result.replace(/\s+class=""/g, '');
  // Remove empty style=""
  result = result.replace(/\s+style=""/g, '');
  // Collapse multiple spaces in line content, preserving leading indentation
  result = result.replace(/^(\s*)(.*)/gm, (_, indent, content) => {
    return indent + content.replace(/ {2,}/g, ' ');
  });
  // Remove blank lines
  result = result.replace(/\n\s*\n\s*\n/g, '\n\n');

  return result;
}

/**
 * Convert a Lit render template to clean static HTML.
 * @param {import('./parser.js').ComponentMeta} meta
 * @returns {string} clean HTML string (inner content only, no host wrapper)
 */
function templateToHTML(meta) {
  const label = meta.pascalName.replace(/([A-Z])/g, ' $1').trim();

  let html = meta.template;

  // 1. Strip ${...} expressions → sensible placeholders
  html = stripExpressions(html);

  // 2. Remove Lit attribute prefixes and parts
  html = stripLitBindings(html);

  // 3. Replace <slot> elements
  html = replaceSlots(html, label);

  // 4. Clean up
  html = cleanHTML(html);

  // 5. Dedent — strip the common leading whitespace from all lines
  html = dedent(html);

  return html;
}

/**
 * Strip the common leading whitespace from all non-empty lines,
 * and trim leading/trailing blank lines.
 */
function dedent(str) {
  const lines = str.split('\n');

  // Find minimum indent of non-empty lines
  let minIndent = Infinity;
  for (const line of lines) {
    if (line.trim().length === 0) continue;
    const spaces = line.match(/^(\s*)/)[1].length;
    if (spaces < minIndent) minIndent = spaces;
  }
  if (!isFinite(minIndent)) minIndent = 0;

  // Strip common indent
  const dedented = lines.map((line) => {
    if (line.trim().length === 0) return '';
    return line.slice(minIndent);
  });

  // Trim leading/trailing blank lines
  while (dedented.length > 0 && dedented[0].trim() === '') dedented.shift();
  while (dedented.length > 0 && dedented[dedented.length - 1].trim() === '') dedented.pop();

  return dedented.join('\n');
}

/**
 * Determine host element tag: span for inline display, div for block display.
 */
function hostTag(meta) {
  const d = meta.hostDisplay || 'block';
  return /^inline/.test(d) ? 'span' : 'div';
}

/**
 * Format HTML with consistent indentation (2-space indent inside host wrapper).
 */
function formatSnippet(innerHTML, wrapTag, wrapAttrs) {
  // Normalize the inner HTML whitespace
  const lines = innerHTML.split('\n').map((l) => l.trimEnd());

  // Find minimum indent of non-empty lines
  const nonEmpty = lines.filter((l) => l.trim().length > 0);
  let minIndent = Infinity;
  for (const line of nonEmpty) {
    const spaces = line.match(/^(\s*)/)[1].length;
    if (spaces < minIndent) minIndent = spaces;
  }
  if (!isFinite(minIndent)) minIndent = 0;

  // Re-indent to 2 spaces inside the wrapper
  const reindented = lines.map((line) => {
    if (line.trim().length === 0) return '';
    return '  ' + line.slice(minIndent);
  }).filter((l, i, arr) => {
    // Remove leading/trailing blank lines
    if (i === 0 && l === '') return false;
    if (i === arr.length - 1 && l === '') return false;
    return true;
  });

  const attrStr = wrapAttrs ? ' ' + wrapAttrs : '';
  return `<${wrapTag}${attrStr}>\n${reindented.join('\n')}\n</${wrapTag}>`;
}

/* ── External HTML generation (class-based) ──────────────────── */

/**
 * Generate the external-CSS HTML variant (component.html).
 * Outputs a clean snippet — no page wrapper.
 */
function generateHTMLExternal(meta, config, root) {
  const prefix = config.prefix;
  const outDir = join(root, config.outDir);
  const fileName = meta.tag.replace(new RegExp('^' + prefix + '-'), '') + '.html';
  const outPath = join(outDir, fileName);

  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const cssFileName = meta.tag.replace(new RegExp('^' + prefix + '-'), '') + '.css';
  const innerHTML = templateToHTML(meta);
  const tag = hostTag(meta);
  const snippet = formatSnippet(innerHTML, tag, `class="${meta.tag}"`);

  const lines = [
    HEADER,
    `<!-- ${meta.tag} — requires ${cssFileName} + tokens.css (or ${prefix}-ui.css) -->`,
    snippet,
    '',
  ];

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}

/* ── Inline HTML generation ──────────────────────────────────── */

/**
 * Check if a CSS selector matches an element.
 * Supports class selectors, descendant combinators, and attribute selectors.
 * @param {string} selector - CSS selector
 * @param {string} elementClass - The class on the element (e.g. 'badge', 'card__inner')
 * @param {string} hostClass - The host class (e.g. 'arc-badge')
 * @param {boolean} isHost - Whether this element IS the host wrapper
 * @returns {boolean}
 */
function selectorMatchesElement(selector, elementClass, hostClass, isHost) {
  const sel = selector.trim();

  if (isHost) {
    // Host element: match selectors like `.arc-badge` (no descendant part)
    // Must start with host class and NOT have a space (descendant combinator)
    if (!sel.startsWith(`.${hostClass}`)) return false;
    const rest = sel.slice(hostClass.length + 1);
    // No descendant part — just attribute qualifiers or pseudo-classes
    return !/\s/.test(rest);
  } else {
    // Inner element: match descendant selectors like `.arc-badge .badge`
    if (!sel.startsWith(`.${hostClass}`)) return false;
    if (!sel.includes(' ')) return false;
    // Get the target part (after last space)
    const parts = sel.split(/\s+/);
    const target = parts[parts.length - 1];
    // Check if target matches the element class
    return target === `.${elementClass}` || target.startsWith(`.${elementClass}:`);
  }
}

/**
 * Collect all inline styles for an element from CSS rules.
 * Only collects from rules without pseudo-states.
 */
function collectStyles(rules, elementClass, hostClass, isHost) {
  const props = new Map();

  for (const rule of rules) {
    if (hasPseudoState(rule.selector)) continue;
    if (rule.media) continue; // Skip @media rules for inline styles
    if (!selectorMatchesElement(rule.selector, elementClass, hostClass, isHost)) continue;

    // Skip rules with attribute selectors (variant-specific) for default rendering
    if (/\[[\w-]/.test(rule.selector)) continue;

    for (const [p, v] of parseDeclarations(rule.declarations)) {
      props.set(p, v);
    }
  }

  if (props.size === 0) return '';
  return [...props.entries()].map(([p, v]) => `${p}: ${v}`).join('; ');
}

/**
 * Collect pseudo-state rules that need to go into a <style> block.
 * Returns CSS text for rules with :hover, :focus, etc.
 */
function collectPseudoRules(rules, hostClass) {
  const pseudoRules = [];

  for (const rule of rules) {
    const hasPseudo = hasPseudoState(rule.selector);
    const hasMedia = !!rule.media;

    if (!hasPseudo && !hasMedia) continue;

    // Only include rules that target our component
    if (!rule.selector.startsWith(`.${hostClass}`)) continue;

    if (hasMedia) {
      pseudoRules.push(`  ${rule.media} {\n    ${rule.selector} { ${rule.declarations} }\n  }`);
    } else {
      pseudoRules.push(`  ${rule.selector} { ${rule.declarations} }`);
    }
  }

  return pseudoRules;
}

/**
 * Apply inline styles to HTML elements and build the <style> block.
 * For each element with a class, match CSS rules → write style="...".
 * Keeps class attributes on elements that have pseudo-state rules targeting them.
 */
function applyInlineStyles(html, rules, hostClass) {
  const pseudoRules = collectPseudoRules(rules, hostClass);

  // Find all elements with class attributes and apply inline styles
  let result = html.replace(
    /<(\w+)(\s[^>]*)?\sclass="([^"]+)"([^>]*?)>/g,
    (match, tagName, before, className, after) => {
      before = before || '';
      after = after || '';
      const style = collectStyles(rules, className, hostClass, false);

      // Check if any pseudo rules target this class — if so, keep the class
      const hasPseudoTarget = pseudoRules.some((r) => r.includes(`.${className}:`));
      const hasMediaTarget = pseudoRules.some((r) => r.includes(`.${className} `) || r.includes(`.${className}`));
      const keepClass = hasPseudoTarget || hasMediaTarget;

      const classAttr = keepClass ? ` class="${className}"` : '';
      const styleAttr = style ? ` style="${style}"` : '';
      return `<${tagName}${before}${classAttr}${styleAttr}${after}>`;
    }
  );

  return { html: result, pseudoRules };
}

/**
 * Generate the inline-styles HTML variant (component.inline.html).
 * Outputs a clean snippet with inline styles + <style> block for pseudo-states.
 */
function generateHTMLInline(meta, config, root) {
  const prefix = config.prefix;
  const outDir = join(root, config.outDir);
  const fileName = meta.tag.replace(new RegExp('^' + prefix + '-'), '') + '.inline.html';
  const outPath = join(outDir, fileName);

  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  // Convert shadow→light CSS then resolve all tokens to literal values
  let componentCSS = shadowToLight(meta.css, meta.tag);
  const baseCSSPath = join(root, config.baseCSS);
  if (existsSync(baseCSSPath)) {
    const tokenMap = loadTokenMap(baseCSSPath);
    componentCSS = resolveTokens(componentCSS, tokenMap);
  }

  const rules = parseCSSRules(componentCSS);
  const innerHTML = templateToHTML(meta);

  // Apply inline styles to inner elements
  const { html: styledInner, pseudoRules } = applyInlineStyles(innerHTML, rules, meta.tag);

  // Collect host styles
  const hostStyle = collectStyles(rules, null, meta.tag, true);
  const tag = hostTag(meta);
  const hostAttrs = [];
  hostAttrs.push(`class="${meta.tag}"`);
  if (hostStyle) hostAttrs.push(`style="${hostStyle}"`);

  const snippet = formatSnippet(styledInner, tag, hostAttrs.join(' '));

  const lines = [HEADER];
  lines.push(`<!-- ${meta.tag} — self-contained, no external CSS needed -->`);

  if (pseudoRules.length > 0) {
    lines.push('<style>');
    lines.push(pseudoRules.join('\n'));
    lines.push('</style>');
  }

  lines.push(snippet);
  lines.push('');

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}


/* ── Public API ──────────────────────────────────────────────── */

/**
 * Generate HTML variants for a component.
 * - 'static' and 'hybrid' components get full HTML+CSS output
 * - 'interactive' components are skipped entirely
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - html config section
 * @param {string} root - project root
 * @returns {{ results: Array<{ path: string, written: boolean }>, skipped: boolean }}
 */
export function generateHTML(meta, config, root) {
  if (meta.interactivity === 'interactive') {
    return { results: [], skipped: true };
  }

  const results = [];
  results.push(generateHTMLExternal(meta, config, root));

  if (config.inlineVariant) {
    results.push(generateHTMLInline(meta, config, root));
  }

  return { results, skipped: false };
}
