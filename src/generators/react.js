// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates React wrapper TypeScript files from ComponentMeta.
 * Uses @lit/react createComponent for proper property/attribute handling and SSR.
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const HEADER = '// Auto-generated by @arclux/prism — do not edit manually';

/**
 * Map a WC property type to a TypeScript type string.
 */
function tsType(prop) {
  if (prop.values && prop.values.length > 0) {
    return prop.values.map((v) => `'${v}'`).join(' | ');
  }
  switch (prop.type) {
    case 'Boolean': return 'boolean';
    case 'Number':  return 'number';
    case 'Array':   return 'unknown[]';
    case 'Object':  return 'Record<string, unknown>';
    default:        return 'string';
  }
}

/**
 * Convert a custom event name to a React handler prop name.
 * 'arc-change' → 'onArcChange'
 * 'click' → 'onClick'
 */
function eventToReactProp(eventName) {
  return 'on' + eventName
    .split('-')
    .map((s) => s[0].toUpperCase() + s.slice(1))
    .join('');
}

/**
 * Generate a React wrapper .ts file for a component.
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - react config section
 * @param {string} root - project root
 * @returns {{ path: string, written: boolean }}
 */
export function generateReact(meta, config, root) {
  const outDir = join(root, config.outDir, meta.tier);
  const outPath = join(outDir, `${meta.pascalName}.ts`);

  // Safety: never overwrite files without our header
  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const wcImport = config.wcPackage || '@arclux/arc-ui';

  const lines = [HEADER, ''];
  lines.push(`import React from 'react';`);
  lines.push(`import { createComponent, type EventName } from '@lit/react';`);
  lines.push(`import { ${meta.className} } from '${wcImport}';`);
  lines.push('');

  // Build props interface (exported for consumers)
  lines.push(`export interface ${meta.pascalName}Props {`);

  for (const prop of meta.props) {
    lines.push(`  ${prop.name}?: ${tsType(prop)};`);
  }

  // Always add className and children
  lines.push('  className?: string;');
  lines.push('  children?: React.ReactNode;');

  // Add event handler props to interface
  const eventMap = buildEventMap(meta);
  for (const [propName, eventName] of Object.entries(eventMap)) {
    if (eventName.startsWith('arc-')) {
      lines.push(`  ${propName}?: (e: CustomEvent) => void;`);
    } else {
      lines.push(`  ${propName}?: (e: Event) => void;`);
    }
  }

  lines.push('}');
  lines.push('');

  // Build createComponent call
  const hasEvents = Object.keys(eventMap).length > 0;
  lines.push(`export const ${meta.pascalName} = createComponent({`);
  lines.push(`  tagName: '${meta.tag}',`);
  lines.push(`  elementClass: ${meta.className},`);
  lines.push(`  react: React,`);

  if (hasEvents) {
    lines.push(`  events: {`);
    for (const [propName, eventName] of Object.entries(eventMap)) {
      const eventType = eventName.startsWith('arc-') ? 'CustomEvent' : 'Event';
      lines.push(`    ${propName}: '${eventName}' as EventName<${eventType}>,`);
    }
    lines.push(`  },`);
  }

  lines.push('});');
  lines.push('');

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}

/**
 * Build the event map for a component.
 */
function buildEventMap(meta) {
  const eventMap = {};
  for (const event of meta.events) {
    eventMap[eventToReactProp(event)] = event;
  }
  // Add native click for button-like components
  if (!meta.events.includes('click') && (meta.tag === 'arc-button' || meta.template.includes('<button'))) {
    eventMap.onClick = 'click';
  }
  return eventMap;
}
