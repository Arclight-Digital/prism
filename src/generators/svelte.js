// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates Svelte 5 component (.svelte) files from ComponentMeta.
 * Uses $props() runes and Snippet type for children.
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const HEADER = '<!-- Auto-generated by @arclux/prism — do not edit manually -->';

/**
 * Map a WC property type to a TypeScript type string.
 */
function tsType(prop) {
  if (prop.values && prop.values.length > 0) {
    return prop.values.map((v) => `'${v}'`).join(' | ');
  }
  switch (prop.type) {
    case 'Boolean': return 'boolean';
    case 'Number':  return 'number';
    case 'Array':   return 'unknown[]';
    case 'Object':  return 'Record<string, unknown>';
    default:        return 'string';
  }
}

/**
 * Format a default value for Svelte destructuring.
 */
function svelteDefault(prop) {
  if (!prop.default) return undefined;
  const val = prop.default;
  if (val.startsWith("'") || val.startsWith('"')) return val;
  if (val === 'true' || val === 'false') return val;
  if (!isNaN(Number(val))) return val;
  return val;
}

/**
 * Generate a Svelte 5 .svelte file for a component.
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - svelte config section
 * @param {string} root - project root
 * @returns {{ path: string, written: boolean }}
 */
export function generateSvelte(meta, config, root) {
  const outDir = join(root, config.outDir, meta.tier);
  const outPath = join(outDir, `${meta.pascalName}.svelte`);

  // Safety: never overwrite files without our header
  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { path: outPath, written: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const wcImport = config.wcPackage;
  const lines = [HEADER];

  // <script lang="ts">
  lines.push('<script lang="ts">');
  lines.push(`  import '${wcImport}';`);
  lines.push(`  import type { Snippet } from 'svelte';`);
  lines.push('');

  // Props interface
  lines.push('  interface Props {');
  for (const prop of meta.props) {
    lines.push(`    ${prop.name}?: ${tsType(prop)};`);
  }
  lines.push('    children?: Snippet;');
  lines.push('    [key: string]: unknown;');
  lines.push('  }');
  lines.push('');

  // $props() destructuring with defaults
  const destructured = [];
  for (const prop of meta.props) {
    const def = svelteDefault(prop);
    if (def !== undefined) {
      destructured.push(`${prop.name} = ${def}`);
    } else {
      destructured.push(prop.name);
    }
  }
  destructured.push('children');
  destructured.push('...rest');

  lines.push(`  let { ${destructured.join(', ')} }: Props = $props();`);
  lines.push('</script>');
  lines.push('');

  // Template
  const attrs = meta.props.map((p) => `{${p.name}}`).join(' ');
  const attrStr = attrs ? ` ${attrs} {...rest}` : ' {...rest}';

  lines.push(`<${meta.tag}${attrStr}>`);
  lines.push(`  {@render children?.()}`);
  lines.push(`</${meta.tag}>`);
  lines.push('');

  writeFileSync(outPath, lines.join('\n'));
  return { path: outPath, written: true };
}
