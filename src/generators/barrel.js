// Auto-generated by @arclux/prism — do not edit manually

/**
 * Updates barrel (index) files for web components and framework wrappers.
 * Append-only — never removes existing exports.
 *
 * Data-driven: each framework defines its export patterns via a config object,
 * and two generic functions handle tier and root barrel updates.
 */

import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

// ── Framework barrel configs ────────────────────────────────

/**
 * @typedef {Object} BarrelConfig
 * @property {string} barrelExt - barrel file extension (e.g. '.js', '.ts')
 * @property {(meta: import('./parser.js').ComponentMeta) => string} existsCheck
 *   - string to search for in existing content to detect duplicates
 * @property {(meta: import('./parser.js').ComponentMeta) => string} tierExportLines
 *   - the export line(s) to append to a tier barrel
 * @property {(meta: import('./parser.js').ComponentMeta) => string} rootExportLines
 *   - the export line(s) to append to a root barrel
 * @property {string} separator - string between existing content and new lines
 * @property {'root-merge'|'root-append'} [rootStrategy] - WC uses merge into existing tier line
 */

/** Web Components barrel config — special root strategy that merges into existing tier export. */
const wcConfig = {
  barrelExt: '.js',
  existsCheck: (meta) => meta.className,
  tierExportLines: (meta, prefix = 'arc') => {
    const fileName = meta.tag.replace(new RegExp('^' + prefix + '-'), '');
    return `export { ${meta.className} } from './${fileName}.js';`;
  },
  separator: '\n',
  rootStrategy: 'root-merge',
  rootExportLines: (meta) => `export { ${meta.className} } from './${meta.tier}/index.js';`,
};

/** Shared config factory for frameworks that use `export { X } from './X.js'` + type exports. */
function typedJsConfig() {
  return {
    barrelExt: '.ts',
    existsCheck: (meta) => meta.pascalName,
    rootExistsCheck: (meta) => `{ ${meta.pascalName} }`,
    tierExportLines: (meta) => [
      `export { ${meta.pascalName} } from './${meta.pascalName}.js';`,
      `export type { ${meta.pascalName}Props } from './${meta.pascalName}.js';`,
    ].join('\n'),
    separator: '\n\n',
    rootStrategy: 'root-append',
    rootExportLines: (meta) => [
      `export { ${meta.pascalName} } from './${meta.tier}/${meta.pascalName}.js';`,
      `export type { ${meta.pascalName}Props } from './${meta.tier}/${meta.pascalName}.js';`,
    ].join('\n'),
  };
}

/** Shared config factory for SFC frameworks (Vue/Svelte) using `export { default as X }`. */
function sfcConfig(ext) {
  return {
    barrelExt: '.ts',
    existsCheck: (meta) => meta.pascalName,
    rootExistsCheck: (meta) => `{ default as ${meta.pascalName} }`,
    tierExportLines: (meta) =>
      `export { default as ${meta.pascalName} } from './${meta.pascalName}.${ext}';`,
    separator: '\n',
    rootStrategy: 'root-append',
    rootExportLines: (meta) =>
      `export { default as ${meta.pascalName} } from './${meta.tier}/${meta.pascalName}.${ext}';`,
  };
}

/** Plain named-export config (Angular) — no type exports, no default-as. */
const angularConfig = {
  barrelExt: '.ts',
  existsCheck: (meta) => meta.pascalName,
  rootExistsCheck: (meta) => `{ ${meta.pascalName} }`,
  tierExportLines: (meta) =>
    `export { ${meta.pascalName} } from './${meta.pascalName}.js';`,
  separator: '\n',
  rootStrategy: 'root-append',
  rootExportLines: (meta) =>
    `export { ${meta.pascalName} } from './${meta.tier}/${meta.pascalName}.js';`,
};

const FRAMEWORK_CONFIGS = {
  wc: wcConfig,
  react: typedJsConfig(),
  solid: typedJsConfig(),
  preact: typedJsConfig(),
  vue: sfcConfig('vue'),
  svelte: sfcConfig('svelte'),
  angular: angularConfig,
};

// ── Generic barrel update functions ─────────────────────────

/**
 * Update a tier-level barrel file (e.g. `content/index.js`).
 * @param {BarrelConfig} cfg
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {string} outDir - absolute path to framework src dir
 * @returns {{ path: string, updated: boolean }}
 */
function updateTierBarrel(cfg, meta, outDir, prefix = 'arc') {
  const barrelPath = join(outDir, meta.tier, `index${cfg.barrelExt}`);
  if (!existsSync(barrelPath)) {
    return { path: barrelPath, updated: false };
  }

  const content = readFileSync(barrelPath, 'utf-8');
  const needle = cfg.existsCheck(meta);

  if (content.includes(needle)) {
    return { path: barrelPath, updated: false };
  }

  const exportLines = cfg.tierExportLines(meta, prefix);
  const updated = content.trimEnd() + cfg.separator + exportLines + '\n';
  writeFileSync(barrelPath, updated);
  return { path: barrelPath, updated: true };
}

/**
 * Update a root-level barrel file (e.g. `index.ts`).
 * Supports two strategies:
 *   - 'root-merge': merge new export name into an existing tier re-export line (WC style)
 *   - 'root-append': append new export line(s) at end of file (all frameworks)
 * @param {BarrelConfig} cfg
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {string} outDir - absolute path to framework src dir
 * @returns {{ path: string, updated: boolean }}
 */
function updateRootBarrel(cfg, meta, outDir) {
  const barrelPath = join(outDir, `index${cfg.barrelExt}`);
  if (!existsSync(barrelPath)) {
    return { path: barrelPath, updated: false };
  }

  const content = readFileSync(barrelPath, 'utf-8');
  const needle = cfg.rootExistsCheck
    ? cfg.rootExistsCheck(meta)
    : cfg.existsCheck(meta);

  if (content.includes(needle)) {
    return { path: barrelPath, updated: false };
  }

  if (cfg.rootStrategy === 'root-merge') {
    // WC-style: try to add to an existing tier re-export line
    const tierExportPattern = new RegExp(
      `^(export\\s*\\{[^}]*\\}\\s*from\\s*['"]\\./${meta.tier}/index\\.js['"];?)$`,
      'm'
    );
    const tierMatch = content.match(tierExportPattern);

    if (tierMatch) {
      const oldLine = tierMatch[0];
      const newLine = oldLine.replace(
        /\}\s*from/,
        `, ${meta.className} } from`
      );
      writeFileSync(barrelPath, content.replace(oldLine, newLine));
    } else {
      const exportLine = cfg.rootExportLines(meta);
      const updated = content.trimEnd() + '\n' + exportLine + '\n';
      writeFileSync(barrelPath, updated);
    }
  } else {
    // Append strategy — all other frameworks
    const exportLines = cfg.rootExportLines(meta);
    const updated = content.trimEnd() + cfg.separator + exportLines + '\n';
    writeFileSync(barrelPath, updated);
  }

  return { path: barrelPath, updated: true };
}

// ── Public API ──────────────────────────────────────────────

export function updateWCBarrel(meta, componentsDir, prefix = 'arc') {
  return updateTierBarrel(FRAMEWORK_CONFIGS.wc, meta, componentsDir, prefix);
}

export function updateWCRootBarrel(meta, componentsDir) {
  return updateRootBarrel(FRAMEWORK_CONFIGS.wc, meta, componentsDir);
}

export function updateReactTierBarrel(meta, reactDir) {
  return updateTierBarrel(FRAMEWORK_CONFIGS.react, meta, reactDir);
}

export function updateReactRootBarrel(meta, reactDir) {
  return updateRootBarrel(FRAMEWORK_CONFIGS.react, meta, reactDir);
}

export function updateVueTierBarrel(meta, vueDir) {
  return updateTierBarrel(FRAMEWORK_CONFIGS.vue, meta, vueDir);
}

export function updateVueRootBarrel(meta, vueDir) {
  return updateRootBarrel(FRAMEWORK_CONFIGS.vue, meta, vueDir);
}

export function updateSvelteTierBarrel(meta, svelteDir) {
  return updateTierBarrel(FRAMEWORK_CONFIGS.svelte, meta, svelteDir);
}

export function updateSvelteRootBarrel(meta, svelteDir) {
  return updateRootBarrel(FRAMEWORK_CONFIGS.svelte, meta, svelteDir);
}

export function updateAngularTierBarrel(meta, angularDir) {
  return updateTierBarrel(FRAMEWORK_CONFIGS.angular, meta, angularDir);
}

export function updateAngularRootBarrel(meta, angularDir) {
  return updateRootBarrel(FRAMEWORK_CONFIGS.angular, meta, angularDir);
}

export function updateSolidTierBarrel(meta, solidDir) {
  return updateTierBarrel(FRAMEWORK_CONFIGS.solid, meta, solidDir);
}

export function updateSolidRootBarrel(meta, solidDir) {
  return updateRootBarrel(FRAMEWORK_CONFIGS.solid, meta, solidDir);
}

export function updatePreactTierBarrel(meta, preactDir) {
  return updateTierBarrel(FRAMEWORK_CONFIGS.preact, meta, preactDir);
}

export function updatePreactRootBarrel(meta, preactDir) {
  return updateRootBarrel(FRAMEWORK_CONFIGS.preact, meta, preactDir);
}
