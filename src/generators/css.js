// Auto-generated by @arclux/prism — do not edit manually

/**
 * Generates standalone CSS files from ComponentMeta.
 * Per-component files + a bundled arc-ui.css.
 * Interactive components are skipped entirely.
 */

import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import { shadowToLight } from '../css-transform.js';

const HEADER = '/* Auto-generated by @arclux/prism — do not edit manually */';

/**
 * Generate a per-component CSS file.
 * @param {import('./parser.js').ComponentMeta} meta
 * @param {object} config - css config section
 * @param {string} root - project root
 * @returns {{ results: Array<{ path: string, written: boolean }>, skipped: boolean }}
 */
export function generateCSS(meta, config, root) {
  if (meta.interactivity === 'interactive') {
    return { results: [], skipped: true };
  }

  const outDir = join(root, config.outDir);
  const prefix = config.prefix;
  const fileName = meta.tag.replace(new RegExp('^' + prefix + '-'), '') + '.css';
  const outPath = join(outDir, fileName);

  // Safety: never overwrite files without our header
  if (existsSync(outPath)) {
    const existing = readFileSync(outPath, 'utf-8');
    if (!existing.startsWith(HEADER)) {
      return { results: [{ path: outPath, written: false }], skipped: false };
    }
  }

  mkdirSync(outDir, { recursive: true });

  const componentCSS = shadowToLight(meta.css, meta.tag);

  const lines = [
    HEADER,
    '',
    `/* ${meta.tag} */`,
    componentCSS.trim(),
    '',
  ];

  writeFileSync(outPath, lines.join('\n'));
  return { results: [{ path: outPath, written: true }], skipped: false };
}

/**
 * Generate the bundled arc-ui.css from all component metas.
 * Interactive components are excluded from the bundle.
 * @param {import('./parser.js').ComponentMeta[]} metas - all parsed components
 * @param {object} config - css config section
 * @param {string} root - project root
 * @returns {Array<{ path: string, written: boolean }>}
 */
export function generateCSSBundle(metas, config, root) {
  const outDir = join(root, config.outDir);
  mkdirSync(outDir, { recursive: true });

  // Filter out interactive components (static + hybrid get CSS)
  const staticMetas = metas.filter((m) => m.interactivity !== 'interactive');

  // Tokens variant — includes :root tokens block + all component CSS with var() refs
  const prefix = config.prefix;
  const tokensPath = join(outDir, prefix + '-ui.css');
  let tokenBlock = '';
  const baseCSSPath = join(root, config.baseCSS);
  if (existsSync(baseCSSPath)) {
    const tokensContent = readFileSync(baseCSSPath, 'utf-8');
    const rootMatch = tokensContent.match(/:root\s*\{([\s\S]*?)\}/);
    if (rootMatch) {
      tokenBlock = `:root {\n${rootMatch[1]}\n}\n`;
    }
  }

  const bundleLines = [
    HEADER,
    '',
    '/* Design Tokens */',
    tokenBlock,
  ];

  for (const meta of staticMetas) {
    const componentCSS = shadowToLight(meta.css, meta.tag);
    bundleLines.push(`/* ${meta.tag} */`);
    bundleLines.push(componentCSS.trim());
    bundleLines.push('');
  }

  writeFileSync(tokensPath, bundleLines.join('\n'));
  return [{ path: tokensPath, written: true }];
}
